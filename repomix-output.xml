This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: ask.sh, README.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  officer/
    create_table.rs
    get_new_data.rs
    query.rs
  main.rs
  officer.rs
  schedule.rs
.gitignore
Cargo.toml
sample.csv
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/officer/create_table.rs">
use rusqlite::{Connection, Result};
use std::error::Error;

pub async fn create_table(conn: &Connection) -> Result<(), Box<dyn Error>> {
    conn.execute(
        "CREATE TABLE IF NOT EXISTS officers (
            id INTEGER PRIMARY KEY,
            reg_code TEXT NOT NULL,
            name TEXT NOT NULL,
            personal_code TEXT NOT NULL
        )",
        [],
    )
    .unwrap();

    Ok(())
}
</file>

<file path="sample.csv">
id;uri;at_legal_entity_registration_number;entity_type;position;governing_body;name;latvian_identity_number_masked;birth_date;legal_entity_registration_number;rights_of_representation_type;representation_with_at_least;registered_on;last_modified_at
108;"";40008093564;NATURAL_PERSON;;EXECUTIVE_BOARD;Familiname Inese;140777-*****;"";"";INDIVIDUALLY;0;2005-08-19;2014-11-04 17:07:09
110;"";40008093564;NATURAL_PERSON;;EXECUTIVE_BOARD;Familiname Iveta;220682-*****;"";"";INDIVIDUALLY;0;2005-08-19;2014-11-04 17:07:09
130;"";40008098858;NATURAL_PERSON;;EXECUTIVE_BODY;Familiname Edgars;310171-*****;"";"";INDIVIDUALLY;0;2006-02-08;2014-11-04 17:07:21
1000014;"";40002000804;NATURAL_PERSON;LIQUIDATOR;;Familiname IÄ¼ja;280158-*****;"";"";INDIVIDUALLY;0;2009-07-03;2009-07-03 16:25:07
</file>

<file path="Cargo.toml">
[package]
name = "kyb"
version = "0.1.0"
edition = "2024"

[dependencies]
actix-web = "4.11.0"
chrono = "0.4.41"
csv = "1.3.1"
reqwest = "0.12.22"
rusqlite = "0.37.0"
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.142"
actix-rt = "2.10.0"
</file>

<file path="src/main.rs">
mod officer;
mod schedule;

//use crate::officer::get_new_data::fetch_and_store_data;
use crate::officer::query::query_officer;
use crate::schedule::schedule_task;
use actix_rt::spawn;
use actix_web::{App, HttpServer, web};

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    //let a = fetch_and_store_data().await;
    // Spawn the schedule task using actix_rt::spawn
    spawn(schedule_task());
    let address = "127.0.0.1:8443";
    // Start the Actix Web server
    println!("KYB server: {}", &address);
    HttpServer::new(|| App::new().route("/lv", web::post().to(query_officer)))
        .bind(address)?
        .run()
        .await
}
</file>

<file path="src/schedule.rs">
use crate::officer::get_new_data::fetch_and_store_data;
use chrono::{Local, Timelike};
use tokio::time::{Duration, Instant, sleep_until};

pub async fn schedule_task() {
    loop {
        let now = Local::now();
        let next_run = now
            .with_hour(2)
            .unwrap()
            .with_minute(0)
            .unwrap()
            .with_second(0)
            .unwrap();

        let duration_until_next_run = if now < next_run {
            next_run - now
        } else {
            next_run + chrono::Duration::days(1) - now
        };

        sleep_until(
            Instant::now() + Duration::from_secs(duration_until_next_run.num_seconds() as u64),
        )
        .await;
        if let Err(e) = fetch_and_store_data().await {
            eprintln!("Error fetching and storing data: {}", e);
        }
    }
}
</file>

<file path=".gitignore">
/target
officers.db
ash.sh
</file>

<file path="src/officer/get_new_data.rs">
use crate::officer::Officer;
use crate::officer::create_table::create_table;
use reqwest::get;
use rusqlite::{Connection, Result, params};
use std::error::Error;
use std::io::Cursor;

pub async fn fetch_and_store_data() -> Result<(), Box<dyn Error>> {
    let url = "https://dati.ur.gov.lv/officers/officers.csv";
    let response = get(url).await?.text().await?;

    let cursor = Cursor::new(response);

    let mut rdr = csv::ReaderBuilder::new()
        .delimiter(b';')
        .from_reader(cursor);

    let conn = Connection::open("officers.db")?;
    // CREATE TABLE, IF DOES NOT EXIST
    create_table(&conn).await?;

    for result in rdr.deserialize() {
        let officer: Officer = result?;
        conn.execute(
            "INSERT OR REPLACE INTO officers (id, reg_code, name, personal_code) VALUES (?1, ?2, ?3, ?4)",
            params![officer.id, officer.at_legal_entity_registration_number, officer.name, officer.latvian_identity_number_masked],
        )?;
    }

    Ok(())
}
</file>

<file path="src/officer.rs">
pub mod create_table;
pub mod get_new_data;
pub mod query;

#[derive(Debug, serde::Deserialize)]
struct Officer {
    id: i32,
    uri: String,
    at_legal_entity_registration_number: String,
    entity_type: String,
    position: Option<String>,
    governing_body: String,
    name: String,
    latvian_identity_number_masked: String,
    birth_date: Option<String>,
    legal_entity_registration_number: Option<String>,
    rights_of_representation_type: String,
    representation_with_at_least: i32,
    registered_on: String,
    last_modified_at: String,
}
</file>

<file path="src/officer/query.rs">
use actix_web::{HttpResponse, Responder, web};
use rusqlite::{Connection, params};
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize)]
pub struct Query {
    name: String,
    personal_code: String,
    reg_code: String,
}

pub async fn query_officer(query: web::Json<Query>) -> impl Responder {
    let conn = Connection::open("officers.db").unwrap();
    let mut stmt = conn
        .prepare("SELECT 1 FROM officers WHERE name = ?1 AND personal_code = ?2 AND reg_code = ?3")
        .unwrap();

    let mut rows = stmt
        .query(params![query.name, query.personal_code, query.reg_code])
        .unwrap();

    if rows.next().unwrap().is_some() {
        HttpResponse::Ok().json(serde_json::json!({ "status": true }))
    } else {
        HttpResponse::Unauthorized().json(serde_json::json!({ "status": false }))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::officer::create_table::create_table;
    use actix_web::{App, test, web};
    use rusqlite::{Connection, params};

    async fn setup_test_db() -> Connection {
        let conn = Connection::open_in_memory().unwrap();
        create_table(&conn).await;
        conn.execute(
            "INSERT INTO officers (id, reg_code, name, personal_code) VALUES (?1, ?2, ?3, ?4)",
            params![1, "40008093564", "Familiname Inese", "140777-*****"],
        )
        .unwrap();
        conn
    }
    #[test]
    async fn test_query_officer_success() {
        let conn = setup_test_db().await;

        let query = Query {
            name: "Familiname Inese".to_string(),
            personal_code: "140777-*****".to_string(),
            reg_code: "40008093564".to_string(),
        };

        let mut stmt = conn
            .prepare(
                "SELECT 1 FROM officers WHERE name = ?1 AND personal_code = ?2 AND reg_code = ?3",
            )
            .unwrap();

        let mut rows = stmt
            .query(params![query.name, query.personal_code, query.reg_code])
            .unwrap();
        assert!(rows.next().unwrap().is_some());
    }

    #[test]
    async fn test_query_officer_failure() {
        let conn = setup_test_db().await;
        let query = Query {
            name: "Nonexistent Name".to_string(),
            personal_code: "000000-*****".to_string(),
            reg_code: "00000000000".to_string(),
        };

        let mut stmt = conn
            .prepare(
                "SELECT 1 FROM officers WHERE name = ?1 AND personal_code = ?2 AND reg_code = ?3",
            )
            .unwrap();

        let mut rows = stmt
            .query(params![query.name, query.personal_code, query.reg_code])
            .unwrap();
        assert!(rows.next().unwrap().is_none());
    }
}
</file>

</files>
